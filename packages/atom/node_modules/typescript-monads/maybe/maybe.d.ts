import { IResult } from '../result/result.interface';
import { IMaybePattern, IMaybe } from './maybe.interface';
export declare class Maybe<T> implements IMaybe<T> {
    private readonly value?;
    constructor(value?: T | null | undefined);
    of(value: T): IMaybe<T>;
    static none<T>(): IMaybe<T>;
    static some<T>(value: T): IMaybe<T>;
    isSome(): boolean;
    isNone(): boolean;
    valueOr(value: NonNullable<T>): NonNullable<T>;
    valueOrUndefined(): T | undefined;
    valueOrNull(): T | null;
    valueOrCompute(fn: () => NonNullable<T>): NonNullable<T>;
    valueOrThrow(msg?: string): NonNullable<T>;
    valueOrThrowErr(err?: Error): NonNullable<T>;
    tap(obj: Partial<IMaybePattern<T, void>>): void;
    tapNone(fn: () => void): void;
    tapSome(fn: (val: NonNullable<T>) => void): void;
    match<R>(pattern: IMaybePattern<T, R>): R;
    toArray(): ReadonlyArray<T>;
    map<R>(fn: (t: NonNullable<T>) => NonNullable<R>): IMaybe<R>;
    mapTo<R>(t: NonNullable<R>): IMaybe<R>;
    flatMap<R>(fn: (d: NonNullable<T>) => IMaybe<R>): IMaybe<R>;
    flatMapAuto<R>(fn: (d: NonNullable<T>) => R): IMaybe<NonNullable<R>>;
    filter(fn: (f: NonNullable<T>) => boolean): IMaybe<T>;
    apply(maybe: IMaybe<ReturnType<T extends (...args: any) => any ? T : any>>): IMaybe<NonNullable<T>>;
    toResult<E>(error: E): IResult<T, E>;
}
//# sourceMappingURL=maybe.d.ts.map