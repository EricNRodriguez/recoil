{"code":"import { ExecutionScopeManager } from \"./inject\";\r\nimport { runEffect } from \"atom\";\r\nimport { nonEmpty } from \"shared\";\r\nclass DeferredContextCallbackRegistry {\r\n    scope;\r\n    constructor() {\r\n        this.scope = [];\r\n    }\r\n    defer(fn) {\r\n        if (!nonEmpty(this.scope)) {\r\n            throw new Error(\"unable to defer functions outside of a scope\");\r\n        }\r\n        this.scope[this.scope.length - 1].push(fn);\r\n    }\r\n    execute(job) {\r\n        try {\r\n            this.scope.push([]);\r\n            const result = job();\r\n            this.scope[this.scope.length - 1].forEach((fn) => fn(result));\r\n            return result;\r\n        }\r\n        finally {\r\n            this.scope.pop();\r\n        }\r\n    }\r\n}\r\nconst contextDeferredCallbackRegistry = new DeferredContextCallbackRegistry();\r\nexport const defer = (deferredFunction) => {\r\n    contextDeferredCallbackRegistry.defer(deferredFunction);\r\n};\r\nexport const onInitialMount = (fn) => {\r\n    let called = false;\r\n    defer((node) => node.registerOnMountHook(() => {\r\n        if (called) {\r\n            return;\r\n        }\r\n        try {\r\n            fn();\r\n        }\r\n        finally {\r\n            called = true;\r\n        }\r\n    }));\r\n};\r\nexport const onMount = (fn) => {\r\n    defer((node) => node.registerOnMountHook(fn));\r\n};\r\nexport const onUnmount = (fn) => {\r\n    defer((node) => node.registerOnUnmountHook(fn));\r\n};\r\n/**\r\n * Runs a side effect against the dom subtree enclosed by this context\r\n *\r\n * The effect will be automatically activated/deactivated with the mounting/unmounting\r\n * of the context, preventing unnecessary background updates to the dom.\r\n *\r\n * @param sideEffect The side effect that will be re-run every time its deps are dirtied.\r\n */\r\nexport const runMountedEffect = (sideEffect) => {\r\n    const ref = runEffect(sideEffect);\r\n    defer((node) => node.registerOnMountHook(ref.activate.bind(ref)));\r\n    defer((node) => node.registerOnUnmountHook(ref.deactivate.bind(ref)));\r\n};\r\nconst scopeManager = new ExecutionScopeManager();\r\n/**\r\n * A type safe DI provider analogous to that provided by the vue composition API.\r\n *\r\n * @param key The injection key.\r\n * @param value The raw value.\r\n */\r\nexport const provide = (key, value) => {\r\n    scopeManager.getCurrentScope().set(key, value);\r\n};\r\n/**\r\n * Returns the value registered against the key, in the current components scope.\r\n *\r\n * This is a tracked operation.\r\n *\r\n * @param key The injection key.\r\n */\r\nexport const inject = (key) => {\r\n    return scopeManager.getCurrentScope().get(key);\r\n};\r\n/**\r\n * Decorates the provided component with a context, allowing the hooks provided by this api\r\n * to be used.\r\n *\r\n * @param component A context builder\r\n */\r\nexport const withContext = (component) => {\r\n    return scopeManager.withChildScope((...args) => {\r\n        // runs the registered callbacks against the returned WElement\r\n        return contextDeferredCallbackRegistry.execute(() => {\r\n            return component(...args);\r\n        });\r\n    });\r\n};\r\n/**\r\n * Wraps a callback inside a closure such that the current contexts scope state is captured and restored for each\r\n * sub-context run inside the callback.\r\n *\r\n * At this point in time, the only scoped state contained within the context API is that used by the dependency\r\n * injection code, however this wrapper fn is intended to be a catch-all single point for wiring in this sort of\r\n * behaviour for any future behaviour that requires similar hierarchical scope.\r\n *\r\n * @param fn The function to close over the current context scope\r\n */\r\nexport const captureContextState = scopeManager.withCurrentScope.bind(scopeManager);\r\n//# sourceMappingURL=api.js.map","references":["/Users/eric.rodriguez/personal/dev/recoil/packages/context/lib/inject.ts","/Users/eric.rodriguez/personal/dev/recoil/packages/context/node_modules/shared/lib/index.ts","/Users/eric.rodriguez/personal/dev/recoil/node_modules/dom/lib/index.ts","/Users/eric.rodriguez/personal/dev/recoil/node_modules/atom/lib/index.ts","/Users/eric.rodriguez/personal/dev/recoil/node_modules/atom/lib/index.ts","/Users/eric.rodriguez/personal/dev/recoil/packages/context/node_modules/shared/lib/index.ts"],"map":"{\"version\":3,\"file\":\"api.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../lib/api.ts\"],\"names\":[],\"mappings\":\"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\"}","dtsmap":{"name":"/Users/eric.rodriguez/personal/dev/recoil/packages/context/node_modules/.cache/rollup-plugin-typescript2/placeholder/packages/context/lib/api.d.ts.map","writeByteOrderMark":false,"text":"{\"version\":3,\"file\":\"api.d.ts\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../lib/api.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,SAAS,EAAyB,MAAM,UAAU,CAAC;AAC5D,OAAO,EACL,QAAQ,EAER,QAAQ,EAET,MAAM,QAAQ,CAAC;AAChB,OAAO,EAAE,QAAQ,EAAS,MAAM,KAAK,CAAC;AAsCtC,eAAO,MAAM,KAAK,qBACE,SAAS,SAAS,WAAW,CAAC,CAAC,KAChD,IAEF,CAAC;AAEF,eAAO,MAAM,cAAc,OAAQ,QAAQ,KAAG,IAe7C,CAAC;AAEF,eAAO,MAAM,OAAO,OAAQ,QAAQ,KAAG,IAEtC,CAAC;AAEF,eAAO,MAAM,SAAS,OAAQ,QAAQ,KAAG,IAExC,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,gBAAgB,eAAgB,QAAQ,KAAG,IAIvD,CAAC;AAIF;;;;;GAKG;AACH,eAAO,MAAM,OAAO,sCAAqC,IAExD,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,MAAM,yCAElB,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,WAAW,mJAYvB,CAAC;AAEF;;;;;;;;;GASG;AACH,eAAO,MAAM,mBAAmB,oHACkB,CAAC\"}"},"dts":{"name":"/Users/eric.rodriguez/personal/dev/recoil/packages/context/node_modules/.cache/rollup-plugin-typescript2/placeholder/packages/context/lib/api.d.ts","writeByteOrderMark":false,"text":"import { SymbolKey } from \"./inject\";\r\nimport { Consumer, Runnable } from \"shared\";\r\nimport { WElement } from \"dom\";\r\nexport declare const defer: (deferredFunction: Consumer<WElement<HTMLElement>>) => void;\r\nexport declare const onInitialMount: (fn: Runnable) => void;\r\nexport declare const onMount: (fn: Runnable) => void;\r\nexport declare const onUnmount: (fn: Runnable) => void;\r\n/**\r\n * Runs a side effect against the dom subtree enclosed by this context\r\n *\r\n * The effect will be automatically activated/deactivated with the mounting/unmounting\r\n * of the context, preventing unnecessary background updates to the dom.\r\n *\r\n * @param sideEffect The side effect that will be re-run every time its deps are dirtied.\r\n */\r\nexport declare const runMountedEffect: (sideEffect: Runnable) => void;\r\n/**\r\n * A type safe DI provider analogous to that provided by the vue composition API.\r\n *\r\n * @param key The injection key.\r\n * @param value The raw value.\r\n */\r\nexport declare const provide: <T>(key: SymbolKey<T>, value: T) => void;\r\n/**\r\n * Returns the value registered against the key, in the current components scope.\r\n *\r\n * This is a tracked operation.\r\n *\r\n * @param key The injection key.\r\n */\r\nexport declare const inject: <T>(key: SymbolKey<T>) => T | undefined;\r\n/**\r\n * Decorates the provided component with a context, allowing the hooks provided by this api\r\n * to be used.\r\n *\r\n * @param component A context builder\r\n */\r\nexport declare const withContext: <Args extends unknown[], ReturnNode extends WElement<HTMLElement>>(component: (...args_0: Args) => ReturnNode) => (...args_0: Args) => ReturnNode;\r\n/**\r\n * Wraps a callback inside a closure such that the current contexts scope state is captured and restored for each\r\n * sub-context run inside the callback.\r\n *\r\n * At this point in time, the only scoped state contained within the context API is that used by the dependency\r\n * injection code, however this wrapper fn is intended to be a catch-all single point for wiring in this sort of\r\n * behaviour for any future behaviour that requires similar hierarchical scope.\r\n *\r\n * @param fn The function to close over the current context scope\r\n */\r\nexport declare const captureContextState: <Args extends unknown[], ReturnType_1>(fn: (...args_0: Args) => ReturnType_1) => (...args_0: Args) => ReturnType_1;\r\n//# sourceMappingURL=api.d.ts.map"}}
